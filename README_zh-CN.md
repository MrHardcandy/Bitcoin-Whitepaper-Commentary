# 比特币：从理论到代码——一份实现级的评注

这份文档旨在为中本聪的比特币白皮书提供一份深入的、代码级别的技术评注。它将白皮书中的高层概念与比特币核心（Bitcoin Core）客户端中的具体C++实现联系起来，弥合理论与工程实践之间的差距。

## 目录
1. [简介：比特币的承诺与核心问题](#简介比特币的承诺与核心问题)
2. [第二章：交易](#第二章交易)
3. [脚本系统：比特币的可编程性](#脚本系统比特币的可编程性)
4. [第三、四章：区块、时间戳与工作量证明](#第三四章区块时间戳与工作量证明)
5. [网络](#网络)
6. [第五、六章：网络与激励](#第五六章网络与激励)
7. [进阶主题：P2SH (Pay-to-Script-Hash)](#进阶主题p2sh-pay-to-script-hash)
8. [进阶主题：时间锁 (Timelocks)](#进阶主题时间锁-timelocks)
9. [进阶主题：隔离见证 (SegWit)](#进阶主题隔离见证-segwit)
10. [钱包技术：用户体验之门](#钱包技术用户体验之门)
11. [历史视角：主要升级与硬分叉](#历史视角主要升级与硬分叉)
12. [11. 计算](#11-计算)


## 简介：比特币的承诺与核心问题

> **白皮书摘录**: "一个纯粹的点对点版本的电子现金，将允许在线支付直接由一方发起，支付给另一方，中间无需经过任何金融机构。"

这句开场白是比特币的独立宣言。它不仅仅是一个愿景，其背后每一个词都由具体的代码和协议规则所支撑。

### "点对点" (Peer-to-Peer) 的实现
比特币网络没有中央服务器。它是一个由成千上万个对等节点组成的扁平化网络。
*   **网络层**: 节点通过 `src/net.cpp` 和 `src/net_processing.cpp` 中的逻辑相互发现和连接。每个节点都维护着一个对等节点列表，并与其他节点直接交换信息。
*   **信息传播**: 交易和区块的传播依赖于我们分析过的**Gossip协议**。当一个节点有新信息时，它通过 `inv` 消息通知其对等节点，对等节点再通过 `getdata` 请求数据。这种机制避免了广播风暴，并使得信息能够在没有中心协调者的情况下，高效地扩散至全网。

### "无需经过金融机构" 的实现
比特币通过将传统银行的三个核心角色（托管、授权、结算）去中心化，从而使其变得多余。
1.  **托管 (Custody)**:
    *   **传统银行**: 银行保管客户的资金。
    *   **比特币实现**: 用户通过**钱包**自己保管资金。我们分析的 **HD钱包 (BIP 32/39)** 技术是关键。用户的资金不与任何中介机构绑定，而是与他们自己持有的**主种子**和派生出的私钥绑定。私钥即所有权。正如那句格言："Not your keys, not your coins."

2.  **授权 (Authorization)**:
    *   **传统银行**: 银行根据账户信息和政策决定一笔转账是否可以发生。
    *   **比特币实现**: 授权是一个纯粹的、非人为干预的**密码学过程**。我们深入分析的 **Script系统** (`src/script/interpreter.cpp`) 是其核心。一笔交易是否有效，取决于花费者能否提供一个有效的 `scriptSig` 来解锁之前输出中的 `scriptPubKey`。核心操作 **`OP_CHECKSIG`** 不关心你是谁，只关心你提供的数字签名是否与公钥匹配。授权的权力完全掌握在私钥的持有者手中。

3.  **结算 (Settlement)**:
    *   **传统银行**: 银行维护一个中心化的账本，并在其上更新各方余额以完成结算。
    *   **比特币实现**: 结算通过一个去中心化的**共识机制**完成，即所有诚实节点对交易历史达成一致意见的过程。这个过程将在下面详细阐述。

### 核心问题——双重花费 (Double-Spending)

> **白皮书摘录**: "数字签名提供了部分解决方案，但如果仍需一个可信的第三方来防止双重花费，那么电子现金的主要优势也就荡然无存了。"

*   **"双重花费"的精确含义**
    在数字世界里，任何信息（一个文件、一串数据）都可以被完美地、零成本地复制。一笔数字现金交易的本质也是一段数据。**双重花费**就是指，恶意用户将同一笔"数字货币"（同一段交易数据或其变种）支付给两个或多个不同的接收者。例如，Alice将同一个比特币支付给Bob，然后又立即将**同一个比特币**支付给Carol。

*   **为什么数字签名本身不足以解决问题**
    数字签名的作用是**验证所有权和真实性**。它可以证明一笔交易确实是由私钥的合法所有者Alice授权的。
    然而，它无法阻止Alice创建**两笔或更多笔独立的、但都合法签名的交易**，这两笔交易都试图花费同一个UTXO。
    *    交易1: Alice -> Bob (花费UTXO_X) -> 合法签名
    *    交易2: Alice -> Carol (花费UTXO_X) -> 合法签名
    Bob和Carol在收到各自的交易时，看到的都是一个密码学上完美无缺的交易。他们无从得知Alice是否也向别人发送了另一笔花费相同资金的交易。没有一个全局的、统一的视角，就无法判断哪一笔交易是"第一笔"也是唯一合法的那笔。这就是需要可信第三方（如银行）来维护单一账本的原因。

### 解决方案 - 一个宏大的系统综合

> **白皮书摘录**: "我们在此提出一个通过点对点网络来解决双重花费问题的方法……该网络通过将交易哈希进一个持续增长的、以哈希为基础的工作量证明链中来为交易打上时间戳……"

比特币的解决方案不是单一的技术，而是一个由五个关键支柱协同工作的、精妙的系统。

1.  **公共账本 (The Public Ledger)**
    *   **概念**: 比特币区块链是一个全球共享、任何人都可以查看和验证的公共账本。所有交易最终都会被公开记录。这种透明性是第一道防线：任何双花尝试都会被公开记录下来，使其无所遁形。

2.  **UTXO 模型 (The Unspent Transaction Output Model)**
    *   **概念**: 比特币不采用银行式的"账户/余额"模型，而是采用我们分析过的 **UTXO 模型**。每一笔可用的资金都是一个独立的、离散的"币"或"票据"（UTXO）。
    *   **协同作用**: 这个模型极大地简化了双花检测。当一笔新交易被广播时，节点不需要检查Alice的"账户余额"是否足够，它们只需要检查这笔交易所引用的**具体UTXO**是否还存在于当前未花费交易输出的集合中。一旦这个UTXO被包含在一个已确认的交易里，它就会从有效UTXO集合中被移除。任何后续试图花费**同一个UTXO**的交易都会因为其输入无效而被立即拒绝。

3.  **时间戳服务器 (The Chain)**
    *   **概念**: 这是防止双花的**排序机制**。通过在 `CBlockHeader` 中包含 `hashPrevBlock` 字段，每个区块都牢牢地锁定了其前一个区块，形成了一条不可分割的时间链。
    *   **协同作用**: 这条链为所有交易提供了一个明确的、唯一的**时间顺序**。即使Alice同时广播了两笔双花交易，由于区块链的线性结构，它们不可能被同时记录在同一个有效历史中。最终只有一个会被接受。篡改这个顺序需要重写整个历史，其难度由下一个支柱来保证。

4.  **工作量证明 (The Cost)**
    *   **概念**: 这是为历史的"书写权"设置的**物理成本**。通过要求矿工不断调整 `nNonce` 来寻找一个低于 `nBits` 规定目标的哈希值，协议确保了向公共账本添加新的一页（区块）需要消耗大量的、真实的物理资源（电力和计算时间）。这个过程由 `CheckProofOfWork` 函数进行验证。
    *   **协同作用**: 工作量证明将纯粹的数字信息与现实世界的物理成本绑定在一起。它使得创造历史的行为变得昂贵，从而阻止了攻击者轻易地创造出另一条"伪造"的历史来替代真实历史。它将"一CPU一票"的民主原则引入了数字世界。

5.  **最长链规则 (The Consensus)**
    *   **概念**: 这是一个简单而强大的**共识算法**。在面对两条或多条都有效的区块链分叉时，所有诚实的节点都遵循一个简单的规则：永远承认并扩展那条拥有最大累计工作量（`nChainWork`）的链作为唯一权威的历史。
    *   **协同作用**: 这是将所有部分粘合在一起的最终粘合剂。它提供了一个无需中心协调、无需投票的机制，让整个去中心化网络能够自动、自发地就单一的历史版本达成共识。即使出现短暂的分叉（例如两个矿工几乎同时找到区块），最长链规则确保了网络最终会收敛到唯一的一条链上，从而明确地使其中一笔双花交易无效。我们分析过的**链重组 (reorg)** 过程正是这一规则在代码中的体现。

**综合起来**: UTXO模型定义了什么是"双花"，公共账本使其可见，时间戳链为其排序，工作量证明使其难以伪造，而最长链规则让所有人对最终的排序达成共识。这五个支柱共同构建了一个无需信任第三方的、坚不可摧的系统来解决双重花费问题。

### 结果 - 不可伪造、篡改成本高昂的历史

> **白皮书摘录**: "……形成一个一旦记录下来就无法更改的记录，除非重做整个工作量证明。"

*   **"不可变性"的量化解释**
    比特币的"不可变性"并非绝对的密码学保证，而是一种**经济学和概率论上的保证**。要篡改历史，攻击者面临的挑战远不止重新计算一个区块的哈希。

*   **攻击者的挑战**:
    假设一个攻击者想篡改6个区块前的一笔交易。他必须：
    1.  修改那个区块中的交易，并重新为**那个区块**找到一个有效的工作量证明。
    2.  由于他改变了区块6的内容，该区块的哈希也变了。这意味着，其后的第5、4、3、2、1个区块的 `hashPrevBlock` 字段全部失效。
    3.  因此，攻击者必须**为所有后续的5个区块也重新找到有效的工作量证明**。
    4.  最关键的是，他必须在他进行这一切的同时，**比整个诚实的比特币网络产生新区块的速度还要快**。否则，诚实链会继续增长，他的分叉链将永远追不上"最长链"。

*   **概率性最终确认与"6个区块"规则**:
    一个攻击者拥有的算力（哈希率）占全网的比例越小，他成功追上并超越诚实链的概率就越呈指数级下降。
    *   **1个确认**: 此时，仍有较小的概率发生自然分叉并导致交易被"回滚"。
    *   **3个确认**: 此时，攻击者需要非常大的算力（例如超过30-40%）和极好的运气才能推翻交易。
    *   **6个确认**: 在这个深度上，除非攻击者掌握了超过51%的全网算力，否则他成功推翻这条包含6个区块的链的概率已经小到可以忽略不计。这就是为什么"6个区块确认"被广泛认为是交易达到**实际上的、经济学意义上的最终确认**的黄金标准。

---

## 第二章：交易

白皮书第二章将交易描述为一个"电子货币的链条"。比特币核心中的 `CTransaction` 类是这一概念的直接代码实现。

*   **核心数据结构**: `CTransaction`
*   **头文件路径**: `bitcoin/src/primitives/transaction.h`

### `CTransaction` 数据结构分析

| 成员变量     | C++ 类型                    | 简要描述                                                                 |
| :----------- | :-------------------------- | :----------------------------------------------------------------------- |
| `version`    | `const uint32_t`            | 交易版本号。用于标识交易遵循的规则集，使得协议的升级和软分叉成为可能。     |
| `vin`        | `const std::vector<CTxIn>`  | 交易输入（Transaction Inputs）的向量（列表）。每个输入都引用了之前一笔交易的输出。 |
| `vout`       | `const std::vector<CTxOut>` | 交易输出（Transaction Outputs）的向量（列表）。每个输出都定义了新的比特币"币"。 |
| `nLockTime`  | `const uint32_t`            | 锁定时间（Lock Time）。这是一个时间戳或区块高度，在此之前，这笔交易是无效的。   |

### 与白皮书概念对比

*   **直接对应**:
    *   `vin` (交易输入) 和 `vout` (交易输出) 是白皮书概念的直接体现。"数字签名链"通过 `vin` 中的 `scriptSig`（通常包含签名）来解锁前一个 `vout` 中的 `scriptPubKey`（锁定条件）来实现。

*   **白皮书中未提及的关键实现**:
    *   **`version` (版本号)**: 允许在不破坏网络共识的情况下引入新规则（如SegWit），是协议能够进化的基础。
    *   **`nLockTime` (锁定时间)**: 为交易增加了时间维度，允许创建在未来才能生效的"期货交易"，是HTLC等复杂合约的基础。

### 交易验证逻辑
当节点收到一笔新交易时，会对其进行"无上下文"的基础检查。

*   **核心函数**: `CheckTransaction`
*   **文件路径**: `bitcoin/src/consensus/tx_check.cpp`
*   **主要检查项**:
    *   确保输入和输出非空。
    *   检查交易大小是否超限。
    *   检查输出值是否为正且在合理范围内。
    *   检查是否存在重复的输入（防止通胀漏洞 CVE-2018-17144）。

---

## 脚本系统：比特币的可编程性
比特币交易的验证依赖于一个功能强大且灵活的栈式脚本语言。

### 核心脚本组件
*   **数据结构**: `CScript`，定义于 `bitcoin/src/script/script.h`。
*   **解释器**: `EvalScript` 函数，位于 `bitcoin/src/script/interpreter.cpp`。
*   **验证入口**: `VerifyScript` 函数，同样位于 `bitcoin/src/script/interpreter.cpp`。

### `scriptSig` 与 `scriptPubKey` 的交互
验证过程是将"钥匙"(`scriptSig`)插入"锁"(`scriptPubKey`)的过程。
1.  **拼接脚本**: `<scriptSig> + <scriptPubKey>`
2.  **执行脚本**: 解释器在一个栈式环境中从头到尾执行拼接后的脚本。
3.  **判断结果**: 如果脚本执行无误且最终栈顶元素为 `TRUE`，则验证成功。

### 关键操作码分析
| Opcode           | 描述                                                                                                                                                                                                   |
| :--------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `OP_DUP`         | **复制**：复制栈顶的元素。                                                                                                                                                                             |
| `OP_HASH160`     | **哈希运算**：对栈顶元素进行 SHA-256 和 RIPEMD-160 两轮哈希。比特币地址即由此产生。                                                                                                                        |
| `OP_EQUALVERIFY` | **等于并验证**：弹出栈顶两个元素比较，若不相等则立即失败。                                                                                                                                                 |
| `OP_CHECKSIG`    | **检查签名**：弹出公钥和签名，使用公钥验证签名对于当前交易的有效性。这是授权的核心。                                                                                                                 |

### P2PKH 脚本执行示例
一个典型的"支付到公钥哈希"（P2PKH）交易，其验证过程完美展示了上述操作码的协同工作。

1.  **锁 (`scriptPubKey`)**: `OP_DUP OP_HASH160 <PubKeyHash> OP_EQUALVERIFY OP_CHECKSIG`
2.  **钥匙 (`scriptSig`)**: `<Signature> <PublicKey>`
3.  **执行步骤**:
    *   `scriptSig` 将签名和公钥压入栈。
    *   `OP_DUP` 复制公钥。
    *   `OP_HASH160` 计算栈顶公钥的哈希，得到花费者提供的公钥哈希。
    *   `<PubKeyHash>` (来自`scriptPubKey`)被压入栈。
    *   `OP_EQUALVERIFY` 比较两个哈希值，如果匹配则继续。这是在验证花费者确实是地址的所有者。
    *   `OP_CHECKSIG` 验证签名，确保交易是由私钥持有人授权的。
    *   最终栈顶留下 `TRUE`，验证成功。

---

## 第三、四章：区块、时间戳与工作量证明

### 核心"区块"数据结构
*   **区块头**: `CBlockHeader`
*   **完整区块**: `CBlock` (继承自 `CBlockHeader` 并包含交易列表 `vtx`)
*   **文件路径**: `bitcoin/src/primitives/block.h`

### 区块头结构分析
| 成员变量         | C++ 类型    | 简要描述                                                                                                                                                             |
| :--------------- | :---------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `nVersion`       | `int32_t`   | **区块版本号**：允许引入新的共识规则。                                                                             |
| `hashPrevBlock`  | `uint256`   | **前一区块的哈希**：将区块链接成"链"的关键，实现了白皮书中的"时间戳服务器"概念。                       |
| `hashMerkleRoot` | `uint256`   | **默克尔树根**：代表了区块中所有交易的、唯一的、固定长度的哈希值。                                           |
| `nTime`          | `uint32_t`  | **时间戳**：该区块被创建的大致时间（Unix时间戳）。                                         |
| `nBits`          | `uint32_t`  | **难度目标（编码后）**：定义了该区块哈希必须满足的难度目标。                                                       |
| `nNonce`         | `uint32_t`  | **随机数（Nonce）**：矿工在进行工作量证明计算时可以随意改变的字段，用以寻找有效哈希。 |

### 默克尔树根
*   **作用**: 使用默克尔树（一种哈希树）可以将区块内所有交易的信息压缩成一个固定长度的哈希值。
*   **优势**: 关键优势在于支持**简单支付验证 (SPV)**。轻客户端无需下载整个区块链，只需下载区块头链，并向全节点索取一笔交易的"默克尔证明"（从交易到树根路径上所必需的哈希），即可独立验证该交易是否被包含在区块中。

### 工作量证明验证逻辑
*   **核心函数**: `CheckProofOfWork`
*   **文件路径**: `bitcoin/src/pow.cpp`
*   **功能**: 该函数将区块头的 `nBits` 解码为256位的难度目标，然后将区块头的哈希值与该目标进行比较。只有当区块哈希**小于或等于**目标值时，才被认为是有效的。

---
## 第五、六章：网络与激励

### 区块传播 - "Gossip"协议
比特币网络采用一种高效的"闲聊"协议来传播新区块，以节省带宽并抵御攻击。
1.  **`inv` (Inventory)**: 矿工向对等节点发送`inv`消息，其中只包含新区块的哈希。
2.  **`getdata`**: 收到`inv`且没有该区块的节点，会回复`getdata`消息请求完整数据。
3.  **`block`**: 发送`inv`的节点在收到`getdata`后，才发送完整的`block`消息。
这个过程确保了节点不会重复下载数据。

### 区块验证与接收
*   **核心协调函数**: `ChainstateManager::ProcessNewBlock` (位于 `src/validation.cpp`)
*   **主要验证阶段**:
    1.  **检查区块结构 (`CheckBlock`)**: 检查PoW、大小、时间戳等是否合规。
    2.  **检查区块内容**: 验证区块内所有交易的有效性（签名、脚本、UTXO是否存在等）。
    3.  **连接到区块链 (`AcceptBlock`)**: 更新UTXO集，将新区块设为新的链顶。

### "最长链即真理"规则
在代码中，这更准确地说是"**累计工作量最大**"的链。每个区块索引`CBlockIndex`都包含一个`nChainWork`成员。
*   **链重组 (Reorg)**: 当一条备选分叉链的`nChainWork`超过了当前主链时，节点会自动进行重组：
    1.  **断开旧块**: 从当前主链顶端回滚区块，将其中的交易放回内存池。
    2.  **连接新块**: 从分叉点开始，逐个连接新链上的区块，使其成为新的主链。
这个自动过程确保了网络总能对单一的权威历史达成共识。

### 激励机制 - Coinbase交易
矿工的激励来自Coinbase交易。
*   **独特性**:
    *   **输入**: Coinbase交易没有常规输入，它"凭空"创造新的比特币。其输入的`prevout`字段为空。
    *   **`scriptSig`**: 内容由矿工自定义，称为 "coinbase data"。
*   **奖励与手续费**:
    *   **区块补贴**: 协议规定的新创造的比特币数量（例如，最初为50 BTC，每210,000个区块减半）。由`GetBlockSubsidy`函数根据区块高度计算。
    *   **交易手续费**: 区块内所有普通交易的"总输入 - 总输出"之和。
    矿工将这两部分相加，作为Coinbase交易的输出值支付给自己。节点在验证时会核对这个总额是否正确。

---

## 进阶主题：P2SH (Pay-to-Script-Hash)

P2SH（BIP 16）将存储复杂脚本的责任从发送方转移到接收方，极大地提升了比特币的易用性。

### P2SH 交易结构
*   **P2SH `scriptPubKey` (锁)**: `OP_HASH160 <20-byte hash of redeemScript> OP_EQUAL`
    它锁定资金到一个脚本的哈希值。
*   **P2SH `scriptSig` (钥匙)**: `<Signature(s)> <Full redeemScript>`
    花费时，必须同时提供满足赎回脚本的签名和完整的赎回脚本本身。

### P2SH 验证逻辑
这是一个两阶段的过程，由`VerifyScript`函数中的特殊规则触发。
1.  **阶段一：验证脚本哈希**:
    *   正常执行 `<scriptSig> + <scriptPubKey>`。
    *   解释器最终会比较`redeemScript`的哈希是否与`scriptPubKey`中的哈希匹配。
    *   如果匹配且脚本格式符合P2SH，则进入第二阶段。
2.  **阶段二：验证赎回脚本**:
    *   解释器将`redeemScript`单独拿出来作为新的待执行脚本。
    *   将`scriptSig`中的签名部分作为新脚本的输入。
    *   执行这个`redeemScript`，其最终结果决定了交易的有效性。

---

## 进阶主题：时间锁 (Timelocks)
时间锁（BIP 65/112）为比特币脚本引入了时间维度，是二层协议的基石。

### `OP_CHECKLOCKTIMEVERIFY` (CLTV) - 绝对时间锁
*   **作用**: 将一个UTXO锁定到一个未来的**绝对时间点**（时间戳或区块高度）。
*   **机制**: CLTV操作码会将栈顶的值与花费交易的`nLockTime`字段进行比较。`nLockTime`必须大于等于栈顶值。
*   **用途**: 无需信任的托管、支付通道的建立。

### `OP_CHECKSEQUENCEVERIFY` (CSV) - 相对时间锁
*   **作用**: 将一个UTXO从其被确认的时刻算起，锁定一段**相对的时间**（区块数或秒数）。
*   **机制**: CSV操作码会将栈顶的值与花费输入的`nSequence`字段进行比较。
*   **用途**: 支付通道的惩罚/争议解决机制，以及其他需要依赖事件发生顺序的合约。

### HTLC (哈希时间锁定合约)
HTLC是闪电网络的核心构件，它巧妙地结合了哈希锁与时间锁。一个HTLC脚本通常有两条花费路径：
1.  **成功路径**: 接收方（Bob）如果在截止日期前出示一个秘密（其哈希值与合约中锁定的一致），即可拿走资金。
2.  **超时/退款路径**: 如果到了截止日期接收方仍未提供秘密，资金的原始发起方（Alice）可以凭自己的签名将资金退还。

在HTLC中，退款路径通常使用 **CLTV（绝对时间锁）**，因为它为合约的各参与方提供了一个全局统一、无争议的截止时间。

---

## 进阶主题：隔离见证 (SegWit)
SegWit（BIP 141-144）是比特币历史上最重要的升级之一。

### 交易延展性 (Transaction Malleability) Bug
*   **问题**: 在SegWit之前，交易签名（`scriptSig`）是计算交易ID（`txid`）的一部分。由于签名的编码方式可以被第三方在不使其失效的情况下略微修改，这会导致`txid`也随之改变。
*   **危害**: 对于依赖未确认交易`txid`的二层协议（如闪电网络）来说，这是致命的，因为它破坏了合约链的完整性。

### SegWit 的解决方案
*   **核心思想**: 将签名等"见证"数据从交易主体中**分离**出去，放入一个全新的`scriptWitness`结构中。
*   **`txid` vs `wtxid`**:
    *   `txid`: 对不包含见证数据的交易部分进行哈希，从而变得不可变，修复了延展性问题。
    *   `wtxid`: 对包含见证数据的完整交易进行哈希，用于网络传输和区块构建。

### 巧妙的软分叉实现
SegWit通过一个"任何人都可以花费"的脚本模式对旧节点隐藏了新规则。
*   **P2WPKH `scriptPubKey`**: `OP_0 <20-byte public key hash>`
*   **旧节点视角**: 将其视为一个总能成功解锁的脚本（只要`scriptSig`为空），因此不会拒绝。
*   **新节点视角**: 识别出这是SegWit V0版本，会去查找并验证交易的`scriptWitness`部分。

### SegWit 的额外好处
*   **变相扩容**: 引入**区块重量（Block Weight）**概念。见证数据的每字节只计为1个重量单位，而核心交易数据计为4个。这使得在400万重量单位的上限下，一个区块可以容纳接近4MB的交易数据。
*   **脚本版本控制**: `OP_0`到`OP_16`被定义为见证程序的版本号，使得未来的脚本升级（如Taproot）可以通过定义新版本号来实现，过程更清晰、简单。

---

## 钱包技术：用户体验之门

### HD 钱包 (BIP 32 & BIP 44)
*   **解决了什么问题**: 解决了早期钱包需要备份大量独立私钥的"密钥集合"（JBOK）问题。
*   **核心概念**:
    *   **BIP 32**: 从一个**主种子**以确定性方式派生出一整棵密钥树。一次备份，永久有效。
    *   **BIP 44**: 为这棵树定义了标准化的层级结构 `m/purpose'/coin_type'/account'/change/address_index`，实现了多币种、多账户管理的兼容性。

### 助记词 (BIP 39)
*   **作用**: 将难以记忆和抄写的二进制种子，编码成一个由12或24个普通单词组成的、用户友好的**助记词短语**，极大地方便了钱包的备份与恢复。

### 交易构建的后台逻辑
1.  **币选择 (Coin Selection)**: 由于UTXO不可分割，钱包需要解决一个优化问题：选择哪些UTXO作为输入，才能在满足支付金额的同时，最小化手续费并保护用户隐私。
2.  **手续费估算 (Fee Estimation)**: 钱包通过连接自己的全节点分析内存池，或通过查询第三方API，来估算当前网络上不同优先级的交易所需要支付的费率（sat/vByte）。
3.  **找零输出 (Change Output)**: 当花费的UTXO总额大于支付金额与手续费之和时，钱包会自动创建一个"找零"输出，将多余的资金安全地返还给用户自己的一个新地址（通常是内部地址）。

---

## 历史视角：主要升级与硬分叉

### 比特币核心（BTC）的主要升级
*   **P2SH**: 提升复杂脚本的易用性和隐私性。
*   **CLTV / CSV**: 增强智能合约能力，引入绝对和相对时间锁。
*   **SegWit**: 修复交易延展性，增加区块容量，并引入脚本版本控制。
*   **Taproot**: 通过施诺尔签名和MAST提升隐私性、效率和脚本灵活性。

### 主要硬分叉项目

#### Bitcoin Cash (BCH)
*   **动机**: 坚持通过**增加基础层区块大小**来实现扩容，以维持低廉的链上手续费，更好地成为"点对点的电子现金"。
*   **技术差异**: 区块大小上限提升至32MB；移除了SegWit；引入了`OP_CHECKDATASIG`等新操作码。
*   **哲学**: 大规模链上扩容是成为世界货币的最佳路径。

#### Bitcoin SV (BSV)
*   **动机**: 认为BCH仍不够彻底，主张完全回归其所理解的"中本聪原始协议"，并彻底解除协议限制。
*   **技术差异**: **完全解除**区块大小上限；主张将协议"锁定"以保持极高稳定性；恢复所有原始操作码。
*   **哲学**: 实现"Metanet"，让区块链不仅是货币，更是承载一切数据和商业活动的全球统一价值互联网。 

---

## 11. 计算

> 我们考虑一个攻击者试图生成一条比诚实链更快的替代链的情况。即使这个目标达到了，也不会使系统变得可以任意修改，比如凭空创建货币或拿走不属于他的钱。节点将不会接受无效的交易作为支付，而且诚实节点永远不会接受一个包含无效交易的区块。攻击者只可能改变他自己的某笔交易来拿回他不久前已经支出的钱。
>
> 诚实链与攻击者链之间的竞争可描述为二项随机漫步。成功事件是诚实节点被延长一个区块，两条链的差距加 1 ，失败事件是攻击者的链延长一个区块，两条链的差距减 1 。
>
> 攻击者从某一落后位置赶上诚实链的概率类似于赌徒破产理论。设想一个拥有无限等码的赌徒从一定亏损开始，进行可能无限次的赌博试图达到盈亏平衡。我们可以计算他达到盈亏平衡，即一个攻击者赶上诚实链的概率，如下 [8]：
>
> p = 诚实节点找到下一个区块的概率
> q = 攻击者找到下一个区块的概率
> q_z = 攻击者从落后 z 个区块赶上诚实链的概率
>
> ![赌徒破产理论公式](https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf)
>
> 我们假设 p > q ，概率将随着攻击者需要赶上的区块数增加而呈指数下降。由于形势对他不利，如果他没有在早期幸运地快速赶上，他落得越远赶上的机会就越渺茫。
>
> 我们现在考虑一个新交易的收款人要等多久才能确保付款人不能再改变这个交易。我们假设作为攻击者的付款人是想让收款人相信他暂时已经付款，然后在一段时间后转换成支付回自己。这时收款人会收到警告，但付款人希望警告已为时已晚。
>
> 收款人生成一个新密钥对并将公钥给付款人，这样付款人就无法提前对交易签名。这能防止付款人通过持续工作直到他足够幸运获得大幅领先的方式预先准备一条区块链，然后在那时执行交易。一旦交易被发出，不诚实的付款人就开始秘密地在一条包含了他的替换版交易的平行链上工作。
>
> 收款人等到交易被加到区块中且其后追加了 z 个区块。他不知道攻击者确切的进度，但是假设诚实的区块按期望的平均时间生成，攻击者可能的进度将是一个泊松分布，其期望值为：
>
> ![泊松分布公式](https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf)
>
> 为计算攻击者现在仍然能赶上的概率，我们给每个他可能达到的进度的泊松密度乘以他在那个进度能赶上诚实链的概率：
>
> ![攻击者追赶概率公式](https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf)
>
> 变换以避免对分布的无限尾部求和...
>
> ![攻击者追赶概率简化公式](https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf)
>
> 转换成 C 语言代码...
>
> ```
> #include <math.h>
> double AttackerSuccessProbability(double q, int z)
> {
>     double p = 1.0 - q;
>     double lambda = z * (q / p);
>     double sum = 1.0;
>     int i, k;
>     for (k = 0; k <= z; k++)
>     {
>         double poisson = exp(-lambda);
>         for (i = 1; i <= k; i++)
>             poisson *= lambda / i;
>         sum -= poisson * (1 - pow(q / p, z - k));
>     }
>     return sum;
> }
> ```
>
> 运行得到一些结果, 我们可以看到概率随 z 呈指数下降。
>
> ```
> q=0.1
> z=0 P=1.0000000
> z=1 P=0.2045873
> z=2 P=0.0509779
> z=3 P=0.0131722
> z=4 P=0.0034552
> z=5 P=0.0009137
> z=6 P=0.0002428
> z=7 P=0.0000647
> z=8 P=0.0000173
> z=9 P=0.0000046
> z=10 P=0.0000012
> q=0.3
> z=0 P=1.0000000
> z=5 P=0.1773523
> z=10 P=0.0416605
> z=15 P=0.0101008
> z=20 P=0.0024804
> z=25 P=0.0006132
> z=30 P=0.0001522
> z=35 P=0.0000379
> z=40 P=0.0000095
> z=45 P=0.0000024
> z=50 P=0.0000006
> ```
>
> P 小于 0.1% 的解...
>
> ```
> P < 0.001
> q=0.10 z=5
> q=0.15 z=8
> q=0.20 z=11
> q=0.25 z=15
> q=0.30 z=24
> q=0.35 z=41
> q=0.40 z=89
> q=0.45 z=340
> ```

### **评注：安全性的经济学基础**

本节为比特币的安全模型提供了数学基础，证明了攻击者成功逆转一笔交易的概率随着其后的区块（确认数）增加而呈指数级下降。"6个区块确认"的经验法则正是这一计算的实际应用，它代表了一个攻击成本变得极其高昂、成功概率对于任何不掌握绝大多数算力的攻击者来说都可以忽略不计的时间点。

---

## 12. 结论

> 我们已经提出了一种不依赖信任的电子交易系统。我们从通用的数字签名货币体系开始，这体系提供了强有力的所有权控制，但由于缺乏防止双重支付的方法而不完善。为解决这个问题，我们提出一种使用工作量证明来记录公共交易历史的点对点网络，只要诚实节点控制了多数的 CPU 算力，对于攻击者，交易历史将很快变得在计算上不可更改。网络因其结构简洁性而强大。节点只需很少的协调就能同时工作。它们不需要被认证，因为信息不会被发送到某个特殊的位置，只需被尽力传播。节点可以随时离开和重新加入网络，只需接受工作量证明链作为它们离开时发生事件的证据。节点使用 CPU 算力来投票，通过致力于延长有效区块来表达对其接受，通过拒绝在无效区块上工作来表达对其抵制。任何需要的规则和激励都可通过这个共识机制来加强。

### **评注：最终的综合**

结论部分精辟地总结了整个系统。它重申了数字签名、点对点网络、工作量证明和最长链规则的结合，如何创造出一个健壮、去中心化且安全的电子现金系统，而这一切都无需依赖任何可信的第三方。我们贯穿比特币核心代码库的旅程，展示了这些高层概念是如何被转化为经过实战检验的、稳健的C++代码的。

---